name: malawi
description: Google Sheets and SFTP Excel to DHIS2 HIV Indicators Pipeline
credentials: null
workflows:
  DHIS2-Indicator-Pipeline:
    name: DHIS2 Indicator Pipeline
    jobs:
      Get-Google-Sheets-Data:
        name: Get Google Sheets Data
        adaptor: '@openfn/language-googlesheets@3.0.13'
        credential: null
        body: |
          // Google Sheets to DHIS2 Data Extraction Job
          // This job reads HIV indicator data from Google Sheets and prepares it for DHIS2

          fn(state => {
            console.log('Starting Google Sheets data extraction...');
            
            // Use configuration from state, with fallbacks
            const config = state.googleSheetsConfig || {
              spreadsheetId: 'YOUR_GOOGLE_SHEET_ID',
              range: 'Sheet1!A:Z'
            };
            
            console.log('Using Google Sheets config:', JSON.stringify(config, null, 2));
            return state;
          });

          getValues({
            spreadsheetId: (state) => state.googleSheetsConfig?.spreadsheetId || 'YOUR_GOOGLE_SHEET_ID',
            range: (state) => state.googleSheetsConfig?.range || 'Sheet1!A:Z'
          }, (state) => {
            console.log('Google Sheets data retrieved:', state.data.values?.length || 0, 'rows');
            
            // Store the raw Google Sheets data
            const sheetData = state.data.values;
            
            // Check if we have data
            if (!sheetData || sheetData.length < 2) {
              throw new Error('No data found in Google Sheets or insufficient rows (need at least headers + 1 data row)');
            }
            
            // Extract headers from first row
            const headers = sheetData[0];
            console.log('Headers found:', headers);
            
            // Get configuration for data processing
            const config = state.googleSheetsConfig || {};
            const skipRows = config.skipHeaderRows || 1;
            
            // Convert rows to objects for easier processing
            const dataRows = sheetData.slice(skipRows).map((row, index) => {
              const rowObj = {
                _rowNumber: index + skipRows + 1, // For debugging
                _originalRow: row
              };
              
              headers.forEach((header, colIndex) => {
                // Clean header names and create object properties
                const cleanHeader = header ? header.toString().trim() : `Column_${colIndex}`;
                const cellValue = row[colIndex] || '';
                rowObj[cleanHeader] = cellValue.toString().trim();
              });
              
              return rowObj;
            });
            
            console.log('Processed', dataRows.length, 'data rows');
            if (dataRows.length > 0) {
              console.log('Sample row:', JSON.stringify(dataRows[0], null, 2));
            }
            
            // Filter out empty rows (rows where all values are empty)
            const validRows = dataRows.filter(row => {
              const nonMetaValues = Object.keys(row)
                .filter(key => !key.startsWith('_'))
                .map(key => row[key]);
              
              return nonMetaValues.some(value => value && value.toString().trim() !== '');
            });
            
            console.log('Valid rows after filtering empty rows:', validRows.length);
            
            // Apply additional filtering based on configuration
            const processingConfig = state.processingConfig || {};
            let finalRows = validRows;
            
            if (processingConfig.dataValidation?.requireIndicatorName) {
              const indicatorCol = config.dataStructure?.indicatorColumn || 'Indicator';
              finalRows = finalRows.filter(row => {
                const hasIndicator = row[indicatorCol] && row[indicatorCol].trim() !== '';
                if (!hasIndicator) {
                  console.warn(`Row ${row._rowNumber}: Missing indicator name in column '${indicatorCol}'`);
                }
                return hasIndicator;
              });
              console.log('Rows with valid indicator names:', finalRows.length);
            }
            
            if (processingConfig.dataValidation?.requireNumericValue) {
              const valueCol = config.dataStructure?.valueColumn || 'Value';
              finalRows = finalRows.filter(row => {
                const value = row[valueCol];
                const isNumeric = !isNaN(parseFloat(value)) && isFinite(value);
                if (!isNumeric && value && value.trim() !== '') {
                  console.warn(`Row ${row._rowNumber}: Invalid numeric value '${value}' in column '${valueCol}'`);
                }
                return isNumeric || !value || value.trim() === '';
              });
              console.log('Rows with valid numeric values:', finalRows.length);
            }
            
            // Store processed data in state for next job
            const result = {
              ...state,
              googleSheetsData: {
                config: config,
                headers: headers,
                rawData: sheetData,
                processedData: finalRows,
                validRowCount: finalRows.length,
                totalRowCount: sheetData.length - skipRows,
                extractedAt: new Date().toISOString(),
                metadata: {
                  spreadsheetId: config.spreadsheetId,
                  range: config.range,
                  skipRows: skipRows
                }
              }
            };
            
            console.log('Google Sheets extraction completed successfully');
            return result;
          });

      Get-SFTP-Excel-Data:
        name: Get SFTP Excel Data
        adaptor: '@openfn/language-sftp@1.0.0'
        credential: null
        body: |
          // Get Excel data from SFTP server with enhanced error handling and retry logic
          // This job downloads Excel files from SFTP and converts them to processable format

          import { 
            sftp,
            downloadFile,
            listFiles,
            each,
            fn,
            dataPath,
            dataValue
          } from '@openfn/language-sftp';

          // SFTP connection configuration with fallback values
          const sftpConfig = {
            host: process.env.SFTP_HOST || 'sftp-server',
            port: parseInt(process.env.SFTP_PORT) || 22,
            username: process.env.SFTP_USER || 'openfn',
            password: process.env.SFTP_PASSWORD || 'instant101',
            algorithms: {
              serverHostKey: ['ssh-rsa', 'ssh-dss'],
              kex: ['diffie-hellman-group14-sha256', 'diffie-hellman-group14-sha1'],
              cipher: ['aes128-ctr', 'aes192-ctr', 'aes256-ctr'],
              hmac: ['hmac-sha2-256', 'hmac-sha2-512', 'hmac-sha1']
            },
            readyTimeout: 20000,
            strictVendor: false
          };

          // Define the Excel files we want to process
          const excelFiles = [
            'DHIS2_HIV Indicators.xlsx',
            'Direct Queries - Q1 2025 MoH Reports.xlsx',
            'Q2FY25_DQ_253_sites.xlsx'
          ];

          // Retry configuration
          const retryConfig = {
            maxRetries: 3,
            retryDelay: 2000,
            backoffMultiplier: 1.5
          };

          // Enhanced file download with retry logic
          function downloadFileWithRetry(remotePath, localPath, fileName, attempt = 1) {
            return fn((state) => {
              console.log(`Downloading ${fileName} (attempt ${attempt}/${retryConfig.maxRetries})`);
              
              return downloadFile(remotePath, localPath, (state) => {
                console.log(`Successfully downloaded ${fileName} to ${localPath}`);
                
                // Verify file was downloaded
                const fs = require('fs');
                if (!fs.existsSync(localPath)) {
                  throw new Error(`Downloaded file not found at ${localPath}`);
                }
                
                const stats = fs.statSync(localPath);
                console.log(`File size: ${stats.size} bytes`);
                
                if (stats.size === 0) {
                  throw new Error(`Downloaded file is empty: ${localPath}`);
                }
                
                // Store successful download info
                if (!state.sftpData) state.sftpData = {};
                if (!state.sftpData.downloadedFiles) state.sftpData.downloadedFiles = [];
                
                state.sftpData.downloadedFiles.push({
                  name: fileName,
                  localPath: localPath,
                  remotePath: remotePath,
                  size: stats.size,
                  downloadedAt: new Date().toISOString(),
                  attempt: attempt
                });
                
                return state;
                
              }).catch((error) => {
                console.error(`Download failed for ${fileName} on attempt ${attempt}:`, error);
                
                if (attempt < retryConfig.maxRetries) {
                  const delay = retryConfig.retryDelay * Math.pow(retryConfig.backoffMultiplier, attempt - 1);
                  console.log(`Retrying ${fileName} in ${delay}ms...`);
                  
                  // In a real implementation, you'd wait here
                  return downloadFileWithRetry(remotePath, localPath, fileName, attempt + 1)(state);
                } else {
                  console.error(`Failed to download ${fileName} after ${retryConfig.maxRetries} attempts`);
                  
                  // Store failure info but don't break the workflow
                  if (!state.sftpData) state.sftpData = {};
                  if (!state.sftpData.failedFiles) state.sftpData.failedFiles = [];
                  
                  state.sftpData.failedFiles.push({
                    name: fileName,
                    remotePath: remotePath,
                    error: error.message,
                    attempts: attempt,
                    failedAt: new Date().toISOString()
                  });
                  
                  return state;
                }
              });
            });
          }

          // Initialize SFTP connection and download files
          sftp(sftpConfig, (state) => {
            console.log('Connected to SFTP server');
            console.log(`Connection config: ${sftpConfig.username}@${sftpConfig.host}:${sftpConfig.port}`);
            
            // Initialize SFTP data tracking
            state.sftpData = {
              connectedAt: new Date().toISOString(),
              config: {
                host: sftpConfig.host,
                port: sftpConfig.port,
                username: sftpConfig.username
              },
              downloadedFiles: [],
              failedFiles: []
            };
            
            // List available files for verification and logging
            return listFiles('/data/excel-files/', (state) => {
              console.log('Available files on SFTP server:', state.data);
              
              // Verify required files exist
              const availableFiles = state.data || [];
              const missingFiles = excelFiles.filter(fileName => 
                !availableFiles.some(file => file.name === fileName || file.includes(fileName))
              );
              
              if (missingFiles.length > 0) {
                console.warn('Missing files on SFTP server:', missingFiles);
              }
              
              // Download each Excel file with error handling
              return each(excelFiles, (fileName) => {
                const remotePath = `/data/excel-files/${fileName}`;
                const localPath = `/tmp/${fileName}`;
                
                console.log(`Attempting to download: ${remotePath} -> ${localPath}`);
                
                return downloadFileWithRetry(remotePath, localPath, fileName);
                
              })((state) => {
                // Summary of download results
                const successful = state.sftpData.downloadedFiles?.length || 0;
                const failed = state.sftpData.failedFiles?.length || 0;
                const total = excelFiles.length;
                
                console.log(`Download summary: ${successful}/${total} successful, ${failed} failed`);
                
                if (successful === 0) {
                  throw new Error('No files were successfully downloaded from SFTP server');
                }
                
                if (failed > 0) {
                  console.warn('Some files failed to download:', state.sftpData.failedFiles.map(f => f.name));
                }
                
                state.sftpData.summary = {
                  totalFiles: total,
                  successfulDownloads: successful,
                  failedDownloads: failed,
                  completedAt: new Date().toISOString()
                };
                
                console.log('SFTP data retrieval completed');
                return state;
              });
            });
          });
                  });
                  
                  return state;
                });
              });
            });
          });

          // Process downloaded Excel files
          fn((state) => {
            console.log('Processing downloaded Excel files...');
            
            if (!state.excelFiles || state.excelFiles.length === 0) {
              throw new Error('No Excel files were downloaded');
            }
            
            // For each downloaded file, we'll need to parse it
            // This is a placeholder - actual Excel parsing would require additional adaptor or processing
            state.sftpData = {
              downloadedFiles: state.excelFiles,
              processedAt: new Date().toISOString(),
              source: 'sftp',
              message: `Successfully downloaded ${state.excelFiles.length} Excel files from SFTP`
            };
            
            console.log('SFTP data retrieval completed:', state.sftpData);
            
            return state;
          });

      Process-Excel-Data:
        name: Process Excel Data
        adaptor: '@openfn/language-common@2.4.0'
        credential: null
        body: |
          // Process Excel data from SFTP and prepare for DHIS2 payload generation
          // This job handles the conversion of Excel data to the format expected by generate-dhis2-payload.js

          import { 
            fn,
            each,
            dataPath,
            dataValue,
            field
          } from '@openfn/language-common';

          import * as XLSX from 'xlsx';
          import fs from 'fs';

          // Data validation schemas
          const validationSchemas = {
            hiv_indicators: {
              requiredColumns: ['indicator', 'value', 'period', 'orgUnit'],
              optionalColumns: ['target', 'comment', 'dataElement']
            },
            direct_queries: {
              requiredColumns: ['site', 'indicator', 'value', 'period'],
              optionalColumns: ['orgUnit', 'target', 'comment']
            },
            dq_sites: {
              requiredColumns: ['site', 'indicator', 'value', 'period'],
              optionalColumns: ['orgUnit', 'score', 'completeness']
            }
          };

          // Enhanced Excel data parsing with real XLSX library
          function parseExcelData(filePath, fileName) {
            console.log(`Parsing Excel file: ${fileName} at ${filePath}`);
            
            try {
              // Check if file exists
              if (!fs.existsSync(filePath)) {
                throw new Error(`File not found: ${filePath}`);
              }

              // Read the Excel file
              const workbook = XLSX.readFile(filePath);
              console.log(`Workbook sheets: ${workbook.SheetNames.join(', ')}`);

              let dataType = 'unknown';
              let parsedData = {};

              // Determine data type based on filename
              if (fileName.includes('DHIS2_HIV Indicators')) {
                dataType = 'hiv_indicators';
                parsedData = parseHIVIndicators(workbook);
              } else if (fileName.includes('Direct Queries')) {
                dataType = 'direct_queries';
                parsedData = parseDirectQueries(workbook);
              } else if (fileName.includes('Q2FY25_DQ')) {
                dataType = 'dq_sites';
                parsedData = parseDQSites(workbook);
              } else {
                // Generic parsing for unknown files
                parsedData = parseGenericExcel(workbook);
              }

              // Validate the parsed data
              const validation = validateExcelData(parsedData, dataType);
              if (!validation.isValid) {
                console.warn(`Data validation warnings for ${fileName}:`, validation.warnings);
              }

              return {
                type: dataType,
                fileName: fileName,
                sheetNames: workbook.SheetNames,
                ...parsedData,
                validation: validation
              };

            } catch (error) {
              console.error(`Error parsing Excel file ${fileName}:`, error);
              throw new Error(`Failed to parse Excel file ${fileName}: ${error.message}`);
            }
          }

          // Parse HIV Indicators Excel file
          function parseHIVIndicators(workbook) {
            const sheetName = workbook.SheetNames[0]; // Use first sheet
            const worksheet = workbook.Sheets[sheetName];
            const jsonData = XLSX.utils.sheet_to_json(worksheet);

            console.log(`Processing ${jsonData.length} rows from HIV Indicators sheet`);

            const indicators = jsonData.map((row, index) => {
              try {
                return {
                  indicator: row['Indicator'] || row['indicator'] || `Row_${index + 1}`,
                  value: parseFloat(row['Value'] || row['value'] || 0),
                  period: row['Period'] || row['period'] || '202506',
                  orgUnit: row['OrgUnit'] || row['orgUnit'] || row['Facility'] || 'MW_DEFAULT',
                  target: parseFloat(row['Target'] || row['target']) || null,
                  comment: row['Comment'] || row['comment'] || null,
                  dataElement: row['DataElement'] || row['dataElement'] || null,
                  rowIndex: index + 1
                };
              } catch (error) {
                console.warn(`Error processing row ${index + 1}:`, error);
                return null;
              }
            }).filter(item => item !== null);

            return { indicators };
          }

          // Parse Direct Queries Excel file with robust column detection
          function parseDirectQueries(workbook) {
            const sheetName = workbook.SheetNames[0];
            const worksheet = workbook.Sheets[sheetName];
            
            // Get raw data with headers
            const rawData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
            console.log(`Processing ${rawData.length} rows from Direct Queries sheet`);
            
            if (rawData.length === 0) {
              return { queries: [] };
            }
            
            // Find header row (look for common patterns)
            let headerRowIndex = 0;
            for (let i = 0; i < Math.min(10, rawData.length); i++) {
              const row = rawData[i];
              if (row && Array.isArray(row)) {
                const hasCommonHeaders = row.some(cell => 
                  cell && typeof cell === 'string' && 
                  (/facility|site|query|indicator|value|result|count|total/i.test(cell) ||
                   /period|month|quarter|year|date/i.test(cell) ||
                   /org|unit|district|region/i.test(cell))
                );
                if (hasCommonHeaders) {
                  headerRowIndex = i;
                  break;
                }
              }
            }
            
            const headers = rawData[headerRowIndex] || [];
            const dataRows = rawData.slice(headerRowIndex + 1);
            
            console.log(`Found headers at row ${headerRowIndex}:`, headers.slice(0, 10));
            
            // Map headers to standard fields
            const headerMap = {};
            headers.forEach((header, index) => {
              if (!header) return;
              
              const headerStr = header.toString().toLowerCase().trim();
              
              // Site/Facility mapping
              if (/^(site|facility|health.*facility|clinic|hospital)$/i.test(headerStr)) {
                headerMap.site = index;
              } else if (/^(query|indicator|measure|metric|data.*element)$/i.test(headerStr)) {
                headerMap.indicator = index;
              } else if (/^(value|result|count|total|number|amount)$/i.test(headerStr)) {
                headerMap.value = index;
              } else if (/^(period|month|quarter|year|date|time)$/i.test(headerStr)) {
                headerMap.period = index;
              } else if (/^(org.*unit|district|region|area)$/i.test(headerStr)) {
                headerMap.orgUnit = index;
              } else if (/^(target|goal|expected)$/i.test(headerStr)) {
                headerMap.target = index;
              } else if (/^(comment|note|remark|description)$/i.test(headerStr)) {
                headerMap.comment = index;
              }
              
              // Additional flexible mappings for common variations
              if (!headerMap.site && /facility|site|clinic/i.test(headerStr)) {
                headerMap.site = index;
              }
              if (!headerMap.indicator && /indicator|query|measure/i.test(headerStr)) {
                headerMap.indicator = index;
              }
              if (!headerMap.value && /value|count|total|result/i.test(headerStr)) {
                headerMap.value = index;
              }
            });
            
            console.log('Header mapping:', headerMap);
            
            const queries = dataRows.map((row, index) => {
              if (!row || !Array.isArray(row) || row.length === 0) return null;
              
              try {
                const site = row[headerMap.site] || row[0] || `Site_${index + 1}`;
                const indicator = row[headerMap.indicator] || row[1] || `Query_${index + 1}`;
                const value = parseFloat(row[headerMap.value] || row[2] || 0);
                
                // Skip empty rows
                if (!site || site.toString().trim() === '' || 
                    !indicator || indicator.toString().trim() === '') {
                  return null;
                }
                
                return {
                  site: site.toString().trim(),
                  indicator: indicator.toString().trim(),
                  value: isNaN(value) ? 0 : value,
                  period: row[headerMap.period] || '2025Q1',
                  orgUnit: row[headerMap.orgUnit] || generateOrgUnit(site),
                  target: parseFloat(row[headerMap.target]) || null,
                  comment: row[headerMap.comment] || null,
                  rowIndex: index + 1
                };
              } catch (error) {
                console.warn(`Error processing Direct Queries row ${index + 1}:`, error);
                return null;
              }
            }).filter(item => item !== null);

            return { queries };
          }

          // Parse DQ Sites Excel file with flexible column detection
          function parseDQSites(workbook) {
            const sheetName = workbook.SheetNames[0];
            const worksheet = workbook.Sheets[sheetName];
            
            // Get raw data with headers
            const rawData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
            console.log(`Processing ${rawData.length} rows from DQ Sites sheet`);
            
            if (rawData.length === 0) {
              return { sites: [] };
            }
            
            // Find header row
            let headerRowIndex = 0;
            for (let i = 0; i < Math.min(10, rawData.length); i++) {
              const row = rawData[i];
              if (row && Array.isArray(row)) {
                const hasDataQualityHeaders = row.some(cell => 
                  cell && typeof cell === 'string' && 
                  (/site|facility|clinic/i.test(cell) ||
                   /quality|score|completeness|timeliness/i.test(cell) ||
                   /dq|data.*quality/i.test(cell))
                );
                if (hasDataQualityHeaders) {
                  headerRowIndex = i;
                  break;
                }
              }
            }
            
            const headers = rawData[headerRowIndex] || [];
            const dataRows = rawData.slice(headerRowIndex + 1);
            
            console.log(`Found DQ headers at row ${headerRowIndex}:`, headers.slice(0, 10));
            
            // Map headers to standard fields
            const headerMap = {};
            headers.forEach((header, index) => {
              if (!header) return;
              
              const headerStr = header.toString().toLowerCase().trim();
              
              // Site/Facility mapping
              if (/^(site|facility|health.*facility|clinic|hospital|hf)$/i.test(headerStr)) {
                headerMap.site = index;
              } else if (/^(score|quality.*score|dq.*score|overall.*score)$/i.test(headerStr)) {
                headerMap.score = index;
              } else if (/^(completeness|complete|data.*complete)$/i.test(headerStr)) {
                headerMap.completeness = index;
              } else if (/^(timeliness|timely|on.*time)$/i.test(headerStr)) {
                headerMap.timeliness = index;
              } else if (/^(period|month|quarter|year|date)$/i.test(headerStr)) {
                headerMap.period = index;
              } else if (/^(org.*unit|district|region|area)$/i.test(headerStr)) {
                headerMap.orgUnit = index;
              } else if (/^(indicator|measure|metric)$/i.test(headerStr)) {
                headerMap.indicator = index;
              }
              
              // Additional flexible mappings
              if (!headerMap.site && /facility|site|clinic|hf/i.test(headerStr)) {
                headerMap.site = index;
              }
              if (!headerMap.score && /score|quality|dq/i.test(headerStr)) {
                headerMap.score = index;
              }
            });
            
            console.log('DQ Sites header mapping:', headerMap);
            
            const sites = dataRows.map((row, index) => {
              if (!row || !Array.isArray(row) || row.length === 0) return null;
              
              try {
                const site = row[headerMap.site] || row[0] || `Site_${index + 1}`;
                
                // Skip empty rows
                if (!site || site.toString().trim() === '') {
                  return null;
                }
                
                // Try to find a numeric value (score, completeness, etc.)
                let value = 0;
                let indicator = 'Data Quality Score';
                
                if (headerMap.score !== undefined && row[headerMap.score] !== undefined) {
                  value = parseFloat(row[headerMap.score]) || 0;
                  indicator = 'Data Quality Score';
                } else if (headerMap.completeness !== undefined && row[headerMap.completeness] !== undefined) {
                  value = parseFloat(row[headerMap.completeness]) || 0;
                  indicator = 'Completeness Rate';
                } else if (headerMap.timeliness !== undefined && row[headerMap.timeliness] !== undefined) {
                  value = parseFloat(row[headerMap.timeliness]) || 0;
                  indicator = 'Timeliness Score';
                } else {
                  // Try to find any numeric column
                  for (let i = 1; i < row.length; i++) {
                    const cellValue = parseFloat(row[i]);
                    if (!isNaN(cellValue)) {
                      value = cellValue;
                      indicator = headers[i] || `Metric_${i}`;
                      break;
                    }
                  }
                }
                
                return {
                  site: site.toString().trim(),
                  indicator: indicator,
                  value: value,
                  period: row[headerMap.period] || '2025Q2',
                  orgUnit: row[headerMap.orgUnit] || generateOrgUnit(site),
                  score: parseFloat(row[headerMap.score]) || null,
                  completeness: parseFloat(row[headerMap.completeness]) || null,
                  timeliness: parseFloat(row[headerMap.timeliness]) || null,
                  rowIndex: index + 1
                };
              } catch (error) {
                console.warn(`Error processing DQ Sites row ${index + 1}:`, error);
                return null;
              }
            }).filter(item => item !== null);

            return { sites };
          }

          // Generic Excel parser for unknown file types
          function parseGenericExcel(workbook) {
            const allData = [];
            
            workbook.SheetNames.forEach(sheetName => {
              const worksheet = workbook.Sheets[sheetName];
              const jsonData = XLSX.utils.sheet_to_json(worksheet);
              
              allData.push({
                sheetName,
                data: jsonData,
                rowCount: jsonData.length
              });
            });

            return { 
              type: 'generic',
              sheets: allData,
              totalRows: allData.reduce((sum, sheet) => sum + sheet.rowCount, 0)
            };
          }

          // Generate org unit ID from site name
          function generateOrgUnit(siteName) {
            if (!siteName) return 'MW_DEFAULT';
            
            // Create a simple org unit ID from site name
            const cleanName = siteName.toString().replace(/[^a-zA-Z0-9]/g, '_').toUpperCase();
            return `MW_${cleanName.substring(0, 10)}`;
          }

          // Validate parsed Excel data
          function validateExcelData(data, dataType) {
            const validation = {
              isValid: true,
              warnings: [],
              errors: []
            };

            if (!validationSchemas[dataType]) {
              validation.warnings.push(`No validation schema for data type: ${dataType}`);
              return validation;
            }

            const schema = validationSchemas[dataType];
            const dataArray = data.indicators || data.queries || data.sites || [];

            if (dataArray.length === 0) {
              validation.errors.push('No data found in Excel file');
              validation.isValid = false;
            }

            // Check required columns
            dataArray.forEach((item, index) => {
              schema.requiredColumns.forEach(column => {
                if (!item[column] && item[column] !== 0) {
                  validation.warnings.push(`Missing required field '${column}' in row ${index + 1}`);
                }
              });

              // Check data types
              if (item.value && isNaN(parseFloat(item.value))) {
                validation.warnings.push(`Invalid numeric value '${item.value}' in row ${index + 1}`);
              }
            });

            return validation;
          }

          // Process the SFTP downloaded files with enhanced error handling
          fn((state) => {
            console.log('Processing Excel data from SFTP...');
            
            if (!state.sftpData?.downloadedFiles) {
              throw new Error('No SFTP data found in state. Make sure get-sftp-data job ran successfully.');
            }
            
            const processedData = [];
            const errors = [];
            
            // Process each downloaded Excel file with retry logic
            state.sftpData.downloadedFiles.forEach(file => {
              console.log(`Processing file: ${file.name}`);
              
              let retryCount = 0;
              const maxRetries = 3;
              let processed = false;
              
              while (!processed && retryCount < maxRetries) {
                try {
                  const parsedData = parseExcelData(file.localPath, file.name);
                  
                  // Additional data transformation for Google Sheets compatibility
                  const transformedData = transformToGoogleSheetsFormat(parsedData);
                  
                  processedData.push({
                    source: 'sftp',
                    fileName: file.name,
                    filePath: file.localPath,
                    ...parsedData,
                    googleSheetsFormat: transformedData,
                    processedAt: new Date().toISOString()
                  });
                  
                  console.log(`Successfully processed ${file.name} with ${parsedData.indicators?.length || parsedData.queries?.length || parsedData.sites?.length || 0} records`);
                  processed = true;
                  
                } catch (error) {
                  retryCount++;
                  console.error(`Error processing ${file.name} (attempt ${retryCount}/${maxRetries}):`, error);
                  
                  if (retryCount >= maxRetries) {
                    errors.push({
                      fileName: file.name,
                      error: error.message,
                      attempts: retryCount
                    });
                  } else {
                    // Wait before retry
                    console.log(`Retrying ${file.name} in 2 seconds...`);
                    // Note: In a real scenario, you'd use setTimeout or similar
                  }
                }
              }
            });
            
            // Store processed data in state for the DHIS2 payload generator
            state.excelData = {
              processedFiles: processedData,
              errors: errors,
              processedAt: new Date().toISOString(),
              totalFiles: processedData.length,
              errorCount: errors.length,
              source: 'sftp',
              summary: {
                hivIndicators: processedData.filter(f => f.type === 'hiv_indicators').length,
                directQueries: processedData.filter(f => f.type === 'direct_queries').length,
                dqSites: processedData.filter(f => f.type === 'dq_sites').length,
                totalRecords: processedData.reduce((sum, file) => {
                  return sum + (file.indicators?.length || file.queries?.length || file.sites?.length || 0);
                }, 0)
              }
            };

            // Transform data to Google Sheets compatible format for downstream processing
            if (processedData.length > 0) {
              state.googleSheetsData = combineDataForGoogleSheets(processedData);
              console.log(`Combined ${processedData.length} files into Google Sheets format`);
            }

            console.log(`Excel data processing complete. Processed: ${processedData.length}, Errors: ${errors.length}`);
            return state;
          });

          // Transform Excel data to Google Sheets compatible format
          function transformToGoogleSheetsFormat(parsedData) {
            const transformed = {
              type: parsedData.type,
              fileName: parsedData.fileName,
              data: []
            };

            if (parsedData.indicators) {
              transformed.data = parsedData.indicators.map(indicator => ({
                'Indicator': indicator.indicator,
                'Value': indicator.value,
                'Period': indicator.period,
                'OrgUnit': indicator.orgUnit,
                'Target': indicator.target || '',
                'Comment': indicator.comment || '',
                'DataElement': indicator.dataElement || ''
              }));
            } else if (parsedData.queries) {
              transformed.data = parsedData.queries.map(query => ({
                'Site': query.site,
                'Indicator': query.indicator,
                'Value': query.value,
                'Period': query.period,
                'OrgUnit': query.orgUnit,
                'Target': query.target || '',
                'Comment': query.comment || ''
              }));
            } else if (parsedData.sites) {
              transformed.data = parsedData.sites.map(site => ({
                'Site': site.site,
                'Indicator': site.indicator,
                'Value': site.value,
                'Period': site.period,
                'OrgUnit': site.orgUnit,
                'Score': site.score || '',
                'Completeness': site.completeness || ''
              }));
            }

            return transformed;
          }

          // Combine multiple Excel files into a single Google Sheets compatible structure
          function combineDataForGoogleSheets(processedFiles) {
            const combined = {
              source: 'sftp_excel',
              processedAt: new Date().toISOString(),
              files: processedFiles.map(f => f.fileName),
              sheets: {}
            };

            processedFiles.forEach(file => {
              const sheetName = file.type.replace('_', ' ').toUpperCase();
              
              if (!combined.sheets[sheetName]) {
                combined.sheets[sheetName] = {
                  data: [],
                  fileCount: 0,
                  recordCount: 0
                };
              }

              if (file.googleSheetsFormat?.data) {
                combined.sheets[sheetName].data.push(...file.googleSheetsFormat.data);
                combined.sheets[sheetName].fileCount++;
                combined.sheets[sheetName].recordCount += file.googleSheetsFormat.data.length;
              }
            });

            return combined;
          }
            
            console.log('Excel data processing completed:', state.excelData);
            
            return state;
          });

          // Transform Excel data to match Google Sheets data structure
          fn((state) => {
            console.log('Transforming Excel data to Google Sheets format...');
            
            if (!state.excelData) {
              return state;
            }
            
            // Convert Excel data to the format expected by generate-dhis2-payload.js
            const transformedData = [];
            
            state.excelData.processedFiles.forEach(file => {
              if (file.type === 'hiv_indicators' && file.indicators) {
                file.indicators.forEach(indicator => {
                  transformedData.push({
                    'Indicator': indicator.indicator,
                    'Value': indicator.value,
                    'Period': indicator.period,
                    'Organisation Unit': indicator.orgUnit,
                    'Source': 'SFTP Excel',
                    'File': file.fileName
                  });
                });
              } else if (file.type === 'direct_queries' && file.queries) {
                file.queries.forEach(query => {
                  transformedData.push({
                    'Indicator': query.indicator,
                    'Value': query.value,
                    'Period': query.period,
                    'Organisation Unit': query.orgUnit,
                    'Site': query.site,
                    'Source': 'SFTP Excel',
                    'File': file.fileName
                  });
                });
              } else if (file.type === 'dq_sites' && file.sites) {
                file.sites.forEach(site => {
                  transformedData.push({
                    'Indicator': site.indicator,
                    'Value': site.value,
                    'Period': site.period,
                    'Organisation Unit': site.orgUnit,
                    'Site': site.site,
                    'Source': 'SFTP Excel',
                    'File': file.fileName
                  });
                });
              }
            });
            
            // Store in the same format as Google Sheets data
            state.googleSheetsData = {
              source: 'sftp_excel',
              processedData: transformedData,
              processedAt: new Date().toISOString(),
              totalRecords: transformedData.length
            };
            
            console.log(`Transformed ${transformedData.length} records from Excel to Google Sheets format`);
            console.log('Sample transformed records:', JSON.stringify(transformedData.slice(0, 3), null, 2));
            
            return state;
          });

      Generate-DHIS2-Payload:
        name: Generate DHIS2 Payload
        adaptor: '@openfn/language-common@2.4.0'
        credential: null
        body: |
          // Generate DHIS2 payload from Google Sheets data
          // This job transforms Google Sheets indicator data into DHIS2 dataValueSets format

          // Generate DHIS2 payload from Google Sheets or Excel data
          // Enhanced to handle both Google Sheets and SFTP Excel data sources

          function generatePayload(inputData, reportConfig) {
            const { catAttrCombo, dataSet, period, orgUnit, hivStagesReportMapping } = reportConfig;
            
            console.log('Generating DHIS2 payload from data...');
            console.log('Report config:', JSON.stringify(reportConfig, null, 2));
            
            // Process input data to extract indicator values
            const indicatorValues = {};
            let dataSource = 'unknown';
            
            // Handle SFTP Excel data format
            if (inputData && inputData.source === 'sftp_excel') {
              dataSource = 'SFTP Excel';
              console.log('Processing SFTP Excel data format');
              
              // Process combined sheets data
              if (inputData.sheets) {
                Object.entries(inputData.sheets).forEach(([sheetType, sheetData]) => {
                  console.log(`Processing ${sheetType} with ${sheetData.recordCount} records`);
                  
                  sheetData.data.forEach(row => {
                    const indicatorName = row['Indicator'] || row['indicator'];
                    const value = row['Value'] || row['value'];
                    const site = row['Site'] || row['site'];
                    
                    if (indicatorName && value !== undefined && value !== '') {
                      // Create unique key for site-specific indicators
                      const indicatorKey = site ? `${site}_${indicatorName}` : indicatorName;
                      const numericValue = parseFloat(value) || 0;
                      
                      indicatorValues[indicatorKey.trim()] = numericValue;
                      console.log(`Mapped ${sheetType} indicator: ${indicatorKey} = ${numericValue}`);
                    }
                  });
                });
              }
              
            } 
            // Handle traditional Google Sheets data format
            else if (inputData && inputData.processedData) {
              dataSource = 'Google Sheets';
              console.log('Processing Google Sheets data format');
              
              inputData.processedData.forEach(row => {
                const indicatorName = row['Indicator'] || row['Indicator Name'] || row['indicator'];
                const value = row['Value'] || row['Count'] || row['Total'] || row['value'];
                
                if (indicatorName && value !== undefined && value !== '') {
                  const cleanIndicatorName = indicatorName.trim();
                  const numericValue = parseFloat(value) || 0;
                  indicatorValues[cleanIndicatorName] = numericValue;
                  console.log(`Mapped Google Sheets indicator: ${cleanIndicatorName} = ${numericValue}`);
                }
              });
            }
            
            // Handle raw Excel data format (fallback)
            else if (inputData && inputData.processedFiles) {
              dataSource = 'Raw Excel';
              console.log('Processing raw Excel data format');
              
              inputData.processedFiles.forEach(file => {
                console.log(`Processing file: ${file.fileName} (${file.type})`);
                
                // Process indicators
                if (file.indicators) {
                  file.indicators.forEach(indicator => {
                    const key = indicator.indicator || `${file.fileName}_${indicator.rowIndex}`;
                    indicatorValues[key.trim()] = parseFloat(indicator.value) || 0;
                    console.log(`Mapped file indicator: ${key} = ${indicator.value}`);
                  });
                }
                
                // Process queries
                if (file.queries) {
                  file.queries.forEach(query => {
                    const key = `${query.site}_${query.indicator}`;
                    indicatorValues[key.trim()] = parseFloat(query.value) || 0;
                    console.log(`Mapped query: ${key} = ${query.value}`);
                  });
                }
                
                // Process sites
                if (file.sites) {
                  file.sites.forEach(site => {
                    const key = `${site.site}_${site.indicator}`;
                    indicatorValues[key.trim()] = parseFloat(site.value) || 0;
                    console.log(`Mapped site: ${key} = ${site.value}`);
                  });
                }
              });
            }
            
            console.log(`Extracted ${Object.keys(indicatorValues).length} indicator values from ${dataSource}`);
            console.log('Sample indicators:', Object.keys(indicatorValues).slice(0, 5));
            
            // Generate DHIS2 dataValues array with enhanced matching
            const dataValues = [];
            const matchingStats = {
              exactMatches: 0,
              partialMatches: 0,
              noMatches: 0,
              defaultValues: 0
            };
            
            Object.entries(hivStagesReportMapping).forEach(([indicatorKey, dhis2DataElement]) => {
              let value = undefined;
              let matchType = 'none';
              
              // Strategy 1: Exact match
              if (indicatorValues.hasOwnProperty(indicatorKey)) {
                value = indicatorValues[indicatorKey];
                matchType = 'exact';
                matchingStats.exactMatches++;
              }
              
              // Strategy 2: Case-insensitive exact match
              if (value === undefined) {
                const exactMatch = Object.keys(indicatorValues).find(key => 
                  key.toLowerCase() === indicatorKey.toLowerCase()
                );
                if (exactMatch) {
                  value = indicatorValues[exactMatch];
                  matchType = 'exact_case_insensitive';
                  matchingStats.exactMatches++;
                }
              }
              
              // Strategy 3: Partial matching (contains)
              if (value === undefined) {
                const partialMatch = Object.keys(indicatorValues).find(key => 
                  key.toLowerCase().includes(indicatorKey.toLowerCase()) ||
                  indicatorKey.toLowerCase().includes(key.toLowerCase())
                );
                if (partialMatch) {
                  value = indicatorValues[partialMatch];
                  matchType = 'partial';
                  matchingStats.partialMatches++;
                  console.log(`Partial match found: "${indicatorKey}" -> "${partialMatch}" = ${value}`);
                }
              }
              
              // Strategy 4: Fuzzy matching for common indicator patterns
              if (value === undefined) {
                const fuzzyMatch = findFuzzyMatch(indicatorKey, Object.keys(indicatorValues));
                if (fuzzyMatch) {
                  value = indicatorValues[fuzzyMatch];
                  matchType = 'fuzzy';
                  matchingStats.partialMatches++;
                  console.log(`Fuzzy match found: "${indicatorKey}" -> "${fuzzyMatch}" = ${value}`);
                }
              }
              
              // Default to 0 if no value found
              if (value === undefined) {
                value = 0;
                matchType = 'default';
                matchingStats.noMatches++;
                console.warn(`No data found for indicator: ${indicatorKey}, defaulting to 0`);
              }
              
              dataValues.push({
                dataElement: dhis2DataElement,
                period: period,
                orgUnit: orgUnit,
                categoryOptionCombo: catAttrCombo,
                attributeOptionCombo: catAttrCombo,
                value: value,
                matchType: matchType,
                originalIndicator: indicatorKey
              });
            });
            
            console.log('Data matching statistics:', matchingStats);
            
            const payload = {
              dataSet: dataSet,
              period: period,
              orgUnit: orgUnit,
              dataValues: dataValues,
              dataSource: dataSource,
              generatedAt: new Date().toISOString(),
              matchingStats: matchingStats
            };
            
            console.log(`Generated DHIS2 payload with ${dataValues.length} data values`);
            return payload;
          }

          // Enhanced fuzzy matching for indicator names
          function findFuzzyMatch(target, candidates) {
            const targetWords = target.toLowerCase().split(/[\s\-_]+/);
            
            let bestMatch = null;
            let bestScore = 0;
            
            candidates.forEach(candidate => {
              const candidateWords = candidate.toLowerCase().split(/[\s\-_]+/);
              let score = 0;
              
              // Calculate word overlap score
              targetWords.forEach(targetWord => {
                candidateWords.forEach(candidateWord => {
                  if (targetWord === candidateWord) {
                    score += 2; // Exact word match
                  } else if (targetWord.includes(candidateWord) || candidateWord.includes(targetWord)) {
                    score += 1; // Partial word match
                  }
                });
              });
              
              // Normalize score by length
              const normalizedScore = score / Math.max(targetWords.length, candidateWords.length);
              
              if (normalizedScore > bestScore && normalizedScore > 0.5) { // Threshold for fuzzy matching
                bestScore = normalizedScore;
                bestMatch = candidate;
              }
            });
            
            return bestMatch;
          }

          fn(state => {
            // Check for data from either Google Sheets or SFTP Excel sources
            const hasGoogleSheetsData = state.googleSheetsData?.processedData;
            const hasSftpData = state.excelData?.processedFiles;
            const hasCombinedSftpData = state.googleSheetsData?.source === 'sftp_excel';
            
            if (!hasGoogleSheetsData && !hasSftpData && !hasCombinedSftpData) {
              throw new Error('No data found in state. Make sure either Google Sheets or SFTP data job executed successfully.');
            }
            
            if (!state.reportConfig) {
              throw new Error('No report configuration found in state. Please ensure reportConfig is properly set.');
            }
            
            // Determine data source and use appropriate data
            let dataToProcess;
            let dataSource;
            
            if (hasCombinedSftpData || hasSftpData) {
              // If we have SFTP data, use it (it should already be transformed to Google Sheets format)
              dataToProcess = state.googleSheetsData || state.excelData;
              dataSource = 'SFTP Excel';
              console.log('Using SFTP Excel data source');
              console.log(`SFTP data summary: ${state.excelData?.summary?.totalRecords || 0} total records`);
            } else {
              dataToProcess = state.googleSheetsData;
              dataSource = 'Google Sheets';
              console.log('Using Google Sheets data source');
            }
            
            // Generate the DHIS2 payload
            const payload = generatePayload(dataToProcess, state.reportConfig);
            
            // Add metadata about the processing
            state.payload = {
              ...payload,
              metadata: {
                originalDataSource: dataSource,
                processedAt: new Date().toISOString(),
                totalDataValues: payload.dataValues?.length || 0,
                hasValidationWarnings: state.excelData?.errors?.length > 0,
                sftpSummary: state.excelData?.summary || null
              }
            };
            
            console.log(`Payload generation completed using ${dataSource}. Generated ${state.payload.totalDataValues || 0} data values.`);
            console.log('Ready for DHIS2 upload.');
            
            return state;
          });

      Upload-to-DHIS2:
        name: Upload to DHIS2
        adaptor: '@openfn/language-dhis2@6.3.4'
        credential: null
        body: |
          // Upload processed data to DHIS2
          // This job sends the generated dataValueSets payload to DHIS2 via the Web API

          fn(state => {
            console.log('Starting DHIS2 upload...');
            
            if (!state.payload) {
              throw new Error('No payload found in state. Ensure the generate-dhis2-payload job executed successfully.');
            }
            
            console.log('Uploading payload to DHIS2:', JSON.stringify(state.payload, null, 2));
            console.log('Number of data values to upload:', state.payload.dataValues.length);
            
            return state;
          });

          // Upload data to DHIS2 using the dataValueSets endpoint
          create("dataValueSets", (state) => {
            const payload = state.payload;
            
            // Add metadata for better tracking
            const enhancedPayload = {
              ...payload,
              completeDate: new Date().toISOString(),
              attribution: {
                source: "Google Sheets via OpenFn",
                workflow: "HIV-Indicators-GoogleSheets-to-DHIS2-Workflow",
                timestamp: new Date().toISOString()
              }
            };
            
            console.log('Sending enhanced payload to DHIS2...');
            return enhancedPayload;
          });

          fn(state => {
            console.log('DHIS2 upload completed successfully!');
            console.log('Response from DHIS2:', JSON.stringify(state.data, null, 2));
            
            // Log summary
            const response = state.data;
            if (response && response.summary) {
              console.log('Upload Summary:', {
                imported: response.summary.imported || 0,
                updated: response.summary.updated || 0,
                ignored: response.summary.ignored || 0,
                deleted: response.summary.deleted || 0
              });
            }
            
            return state;
          });
    triggers:
      webhook:
        type: webhook
        enabled: true
      cron:
        type: cron
        cron_expression: '00 00 01 * *'
        enabled: true
    edges:
      webhook->Get-Google-Sheets-Data:
        source_trigger: webhook
        target_job: Get-Google-Sheets-Data
        condition_type: always
        enabled: true
      cron->Get-SFTP-Excel-Data:
        source_trigger: cron
        target_job: Get-SFTP-Excel-Data
        condition_type: always
        enabled: true
      Get-Google-Sheets-Data->Generate-DHIS2-Payload:
        source_job: Get-Google-Sheets-Data
        target_job: Generate-DHIS2-Payload
        condition_type: on_job_success
        enabled: true
      Get-SFTP-Excel-Data->Process-Excel-Data:
        source_job: Get-SFTP-Excel-Data
        target_job: Process-Excel-Data
        condition_type: on_job_success
        enabled: true
      Process-Excel-Data->Generate-DHIS2-Payload:
        source_job: Process-Excel-Data
        target_job: Generate-DHIS2-Payload
        condition_type: on_job_success
        enabled: true
      Generate-DHIS2-Payload->Upload-to-DHIS2:
        source_job: Generate-DHIS2-Payload
        target_job: Upload-to-DHIS2
        condition_type: on_job_success
        enabled: true
